=head1 NAME

aa-stop - Stop services

=head1 SYNOPSIS

B<aa-stop> [B<-D>] [B<-r> I<repodir>] [B<-a>] [B<-k> I<service>]
[B<-t> I<timeout>] [I<service...>]

=head1 OPTIONS

=over

=item B<-a, --all>

Stops all running/started services. This option is intended to be used during
stage 3; When used, you shouldn't specify any service on the command line.
See below for its implications.

=item B<-D, --double-output>

Enable double-output mode. Instead of using stdout for regular output, and
stderr for warnings and errors, everything is sent both to stdout and stderr.
This is intended to redirect stderr to a log file, so full output can be both
shown on console and logged.

=item B<-h, --help>

Show help screen and exit.

=item B<-k, --skip> I<service>

If I<service> was asked to be stopped, silently ignore it. This is intended for
use alongside B<--all> to keep the catch-all logger service running as long as
possible (It will be stopped when sending SIGTERM to all running processes.).

=item B<-r, --repodir> I<dir>

Use I<dir> as repository directory. This is where servicedirs will be looked
for.

=item B<-t, --timeout> I<timeout>

Set default timeout to I<timeout> seconds. You can use 0 for no timeout.
Timeout can also be set in service in a file I<timeout> in its servicedir.

=item B<-V, --version>

Show version information and exit.

=back

=head1 DESCRIPTION

B<aa-stop>(1) allows to stop one or more services. Unlike B<aa-start>(1) it
doesn't take into account any dependency relation, and the only services that
will be stopped are those asked to be stopped.

It does however accounts for I<after> and I<before> to stop services in reverse
order they were started in, treating I<needs> exactly as it does I<after>.

Refer to B<anopa>(1) for descriptions of servicedirs and service dependencies.

B<aa-stop>(1) works in a very similar manner as B<aa-start>(1), with the
following differences :

=head1 STOPPING A LONG-RUN SERVICE

B<aa-stop>(1) will check if the service is running, and if not simply announce
it as not up.

When B<--all> is used, if the service has a logger then command 'x' will be sent
to said logger's B<s6-supervise> first, so that when the logger exits it isn't
restarted and B<s6-supervise> exits as well instead.

Similarly, instead of 'd' the commands 'dx' are sent to the service's
B<s6-supervise>, so that after bringing the service down it exits as well. This
is obviously all intended to bring the supervised tree all down, as is expected
when using B<--all> (usually from stage 3).

Note that if a service was not running, no 'x' command is sent so the
B<s6-supervise> process of the service - and of its logger, if any - are kept
running. This isn't a problem, since they'll simply exit when sending SIGTERM to
all process further down in stage 3.

=head2 Service not up

When you call B<aa-stop>(1) it will first create a list of all services to be
stopped. Any service specified that isn't up will simply be ignored with a "Not
up" message shown.

It should be noted that, for long-run services, it is possible that a service
was up then, but will be down by the time B<aa-stop>(1) wants to stop it. E.g.
because other services stopped first caused it to stop/crash.

In such a case, the message "Stopping service..." will be shown, and
B<aa-stop>(1) will send the command(s) as usual; But it won't check for errors
(nor wait for the 'd' event) and simply report the service as "Not up" instead.

This should ensure that e.g. s6 doesn't restart the service, or stops it if that
was already (being) done, and in case B<--all> was used that the B<s6-supervise>
process(es) will exit as expected.

=head1 STOPPING A ONE-SHOT SERVICE

Obviously, the script used is I<stop> and not I<start>. Other than that, the
process is much the same, so you can refer to B<aa-start>(1) for more.
